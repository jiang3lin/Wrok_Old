/*******************************************************************************
 *
 *       Copyright (c) 2005-2011 by iCatch Technology, Inc.
 *
 *  This software is copyrighted by and is the property of iCatch Technology,
 *  Inc.. All rights are reserved by iCatch Technology, Inc..
 *  This software may only be used in accordance with the corresponding
 *  license agreement. Any unauthorized use, duplication, distribution,
 *  or disclosure of this software is expressly forbidden.
 *
 *  This Copyright notice MUST not be removed or modified without prior
 *  written consent of iCatch Technology, Inc..
 *
 *  iCatch Technology, Inc. reserves the right to modify this software
 *  without notice.
 *
 *  iCatch Technology, Inc.
 *  19-1, Innovation First Road, Science-Based Industrial Park,
 *  Hsin-Chu, Taiwan, R.O.C.
 *
 *
 ******************************************************************************/
#if SPCA6330
 
#include <string.h>
#include "common.h"
#include "customization/solution_def.h"

/**************************************************************************
 *                           C O N S T A N T S                            *
 **************************************************************************/
#define RAM_START_ADDR ((void *)0xa0000000)

/**************************************************************************
 *                              M A C R O S                               *
 **************************************************************************/

/**************************************************************************
 *                 E X T E R N A L    R E F E R E N C E S                 *
 **************************************************************************/
extern UINT32 _bssStart;
extern UINT32 _bssEnd __attribute__ ((section (".bss")));
extern UINT32 _dram_content_lma_start __attribute__ ((section (".rom")));;
extern UINT32 _dram_content_vma_start __attribute__ ((section (".text")));;
extern void addrInit(void);
extern void _exceptVect(void);

extern void QUARTInit(void);
extern void QUARTChar(UINT8);
extern void QUART(UINT32 , UINT32 , UINT32);

/**************************************************************************
 *                          D A T A    T Y P E S                          *
 **************************************************************************/
typedef struct memProfile_s {
	void *pdataLma;
	void *pdataVma;
	void *pheapStart;
	void *pheapEnd;
} memProfile_t;

/**************************************************************************
 *                         G L O B A L    D A T A                         *
 **************************************************************************/
memProfile_t memProfile __attribute__ ((section (".sbss")));

/**************************************************************************
 *               F U N C T I O N    D E C L A R A T I O N S               *
 **************************************************************************/
void   __init(void)       __attribute__ ((section (".boot")));
static UINT32 dramSizeTest(void) __attribute__ ((section (".boot")));

void QUARTDump(void *paddr, int size) __attribute__ ((section (".boot")));
/**
 * \brief dump the target address by QUARTChar.
 * \param paddr The address to be dumped.
 * \param size The dumped size.
 */
void QUARTDump(void *paddr, int size)
{
	int i;
	UINT8 *ptr;
	ptr = (UINT8 *)((UINT32)paddr & -(UINT32)16);
	QUARTChar(0x0d); QUARTChar(0x0a);
	QUART(*ptr, 8, 1);
	QUARTChar(':');
	QUARTChar(' ');
	for (i = 0; (i < 16) && size; i++, ptr++) {
		if (i == 8) { QUARTChar('\b'); QUARTChar('-'); }
		if (ptr < (UINT8 *)paddr) {
			QUARTChar(' ');
			QUARTChar(' ');
			QUARTChar(' ');
		}
		else {
			size--;
			QUART(*ptr, 2, 1);
			QUARTChar(' ');
		}
	}
	for (i = 0; i < size; i++)
	{
		if (!(i & 0xf)) { 
			QUARTChar(0x0d); QUARTChar(0x0a); QUART(*ptr, 8, 1);
			QUARTChar(':'); QUARTChar(' ');
		}
		else if (!(i & 0x7)) { QUARTChar('\b'); QUARTChar('-'); }
		QUART(*ptr++, 2, 1);
		QUARTChar(' ');
	}
	QUARTChar(0x0d); QUARTChar(0x0a);

}


/**
 * \brief Check the dram size
 *
 * When we use nand, the dram size is specified in dram parameter. Otherwise,
 * we auto check the dram size here. (Typically for fpga verification)
 */
UINT32
dramSizeTest(
	void
)
{
#if SPCA5310
	volatile UINT8  *preg = (UINT8 *)0xb0007050;
	/* DRAM size undetermined yet */
	#ifndef RAM_PROGRAM
	volatile UINT32 *pstart = (UINT32 *)RAM_START_ADDR;
	volatile UINT32 *pread;
	UINT32 i = 0x20;
	UINT32 j, k;
	UINT32 bits = 26/*unit:double-word*/, memSize = 256 * 1024 * 1024;/*unit:byte*/

	while ( i >= 1 ) {
		*preg = (*preg & 0xc0) | i;
		k = i;
		    
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			#if 0 /* TGGPIO */
		    WRITE8(0xb0009032,4); /* tggpioo, set TG GPIO 2 value as 1 */
			WRITE8(0xb0009030,4); /* tggpiooe, set TG GPIO 2 output enable */
			/*QUART(READ8(0xb0009032),2,1);QUART_NEWLINE*/
			#endif

			*pread = 0x55aaaa55;
			/*QUART(*pread,8,1);QUART_NEWLINE*/
		}
		*pstart = 0xf0f0f0f0;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			/*QUART(*pread,8,1);QUART_NEWLINE*/
			if ( *pread == 0xf0f0f0f0 ) {
				i=i>>1;
				bits--;
				memSize = memSize >> 1;
				break;
			}
		}
		if ( k == i ) {
			break;
		}
	}
	#else

	/* DRAM size determined in boot code earlier */
	UINT32 memSize = (UINT32)(*preg & 0x3f) * 8 * 1024 * 1024;

	#endif
#else /*SPCA5210*/

	volatile UINT8  *preg = (UINT8 *)0xb0007050;
	#ifndef RAM_PROGRAM
	/* DRAM size undetermined yet */
	volatile UINT32 *pstart = (UINT32 *)RAM_START_ADDR;
	volatile UINT32 *pread;
	UINT32 i = 6;
	UINT32 j, k;
	UINT32 bits = 25, memSize = 128 * 1024 * 1024;

	while ( i >= 3 ) {
		*preg = (*preg & 0xf8) | i;
		k = i;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			*pread = 0;
		}
		*pstart = 0xffffffff;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			if ( *pread == 0xffffffff ) {
				i--;
				bits--;
				memSize = memSize >> 1;
				break;
			}
		}
		if ( k == i ) {
			break;
		}
	}
	#else

	/* DRAM size determined in boot code earlier */
	UINT32 memSize = (2 * 1024 * 1024) << (UINT32)(*preg & 0x07);

	#endif/*RAM_PROGRAM*/

#endif/*SPCA5310*/

#ifndef RAM_PROGRAM
	addrInit();
#endif

/* emulating limited memory in realkit */
#if FORCE_DRAM_SMALL_SIZE
	if ( memSize > FORCE_DRAM_SMALL_SIZE )
		memSize = FORCE_DRAM_SMALL_SIZE;
#endif
	return memSize;
}

#if !defined(RAM_PROGRAM) && !defined(_FPGA_HW_)
#if SPCA6330
const UINT8 dramParamData[] __attribute__ ((section (".bootParam"))) = {
#if DDR2
	#if 1 /* BGA/Socket 135MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x33, 0x00, 0x08, 0xFD, 0x6A, 0x70, 0xFF, 0x6B,
	0x70, 0x0F, 0x80, 0x70, 0x01, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70,
	0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00,
	0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91,
	0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70,
	0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0,
	0x54, 0x70, 0x06, 0x55, 0x70, 0x04, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59,
	0x70, 0x13, 0x5A, 0x70, 0x06, 0x5B, 0x70, 0x07, 0x5D, 0x70, 0x11, 0x5E, 0x70, 0x0B, 0x5F, 0x70,
	0x11, 0x64, 0x70, 0x30, 0x65, 0x70, 0x05, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00,
	0x69, 0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6,
	0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 165MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x37, 0x00, 0xF6, 0x00, 0x89, 0x00, 0x04, 0x7A,
	0x00, 0xDC, 0x7B, 0x00, 0x00, 0x8E, 0x00, 0x0D, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70,
	0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A,
	0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D,
	0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70,
	0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00,
	0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF0, 0x55,
	0x70, 0x04, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59, 0x70, 0x17, 0x5A, 0x70,
	0x08, 0x5B, 0x70, 0x09, 0x5D, 0x70, 0x15, 0x5E, 0x70, 0x0B, 0x5F, 0x70, 0x11, 0x64, 0x70, 0x30,
	0x65, 0x70, 0x05, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73,
	0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6, 0x70, 0x02, 0x51, 0x70,
	0x04,
	#elif 0 /* BGA 189MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x38, 0x00, 0x6F, 0x01, 0x89, 0x00, 0x05, 0x8A,
	0x00, 0x08, 0x7A, 0x00, 0xFC, 0x7B, 0x00, 0x00, 0x8E, 0x00, 0x0F, 0x6A, 0x70, 0xFF, 0x6B, 0x70,
	0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00,
	0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C,
	0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70,
	0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00,
	0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54,
	0x70, 0xAB, 0x55, 0x70, 0x05, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59, 0x70,
	0x1A, 0x5A, 0x70, 0x09, 0x5B, 0x70, 0x0A, 0x5D, 0x70, 0x18, 0x5E, 0x70, 0x0B, 0x5F, 0x70, 0x11,
	0x64, 0x70, 0x30, 0x65, 0x70, 0x05, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69,
	0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6, 0x70,
	0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 222.75MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x38, 0x00, 0xCA, 0x00, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x09, 0x7A, 0x00, 0x29, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x12, 0x6A, 0x70, 0xFF, 0x6B, 0x70,
	0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00,
	0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C,
	0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70,
	0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00,
	0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54,
	0x70, 0xB2, 0x55, 0x70, 0x06, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59, 0x70,
	0x1F, 0x5A, 0x70, 0x0B, 0x5B, 0x70, 0x0C, 0x5D, 0x70, 0x1C, 0x5E, 0x70, 0x0C, 0x5F, 0x70, 0x21,
	0x64, 0x70, 0x30, 0x65, 0x70, 0x07, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69,
	0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6, 0x70,
	0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 243MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0xAE, 0x01, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x0A, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x44, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x13, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x50, 0x55, 0x70, 0x07, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x16, 0x59, 0x70, 0x22, 0x5A, 0x70, 0x0C, 0x5B, 0x70, 0x0D, 0x5D, 0x70, 0x1E,
	0x5E, 0x70, 0x0C, 0x5F, 0x70, 0x21, 0x64, 0x70, 0x30, 0x65, 0x70, 0x07, 0x66, 0x70, 0x0A, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70,
	0x07, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 267MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x9F, 0x01, 0x89, 0x00, 0x07, 0x8A,
	0x00, 0x0B, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x64, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x15, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0B, 0x55, 0x70, 0x08, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x18, 0x59, 0x70, 0x25, 0x5A, 0x70, 0x0D, 0x5B, 0x70, 0x0F, 0x5D, 0x70, 0x22,
	0x5E, 0x70, 0x0E, 0x5F, 0x70, 0x21, 0x64, 0x70, 0x30, 0x65, 0x70, 0x09, 0x66, 0x70, 0x0A, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x08, 0x75, 0x70,
	0x07, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 297MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0x1B, 0x04, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x8C, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF5, 0x55, 0x70,
	0x08, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x19, 0x59, 0x70, 0x29, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x10, 0x5D, 0x70, 0x25, 0x5E, 0x70, 0x10, 0x5F, 0x70, 0x21, 0x64, 0x70, 0x40, 0x65,
	0x70, 0x09, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x06, 0x74, 0x70, 0x09, 0x75, 0x70, 0x07, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 333MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0x38, 0x05, 0x89, 0x00, 0x09, 0x8A,
	0x00, 0x13, 0x92, 0x00, 0x17, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xBC, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1B,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0A, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0E, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x19, 0x59, 0x70, 0x2E, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x12, 0x5D, 0x70, 0x2A, 0x5E,
	0x70, 0x10, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x40, 0x65, 0x70, 0x09, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x07, 0x74, 0x70, 0x09, 0x75, 0x70, 0x08,
	0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 360MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0x4A, 0x06, 0x89, 0x00, 0x0A, 0x8A,
	0x00, 0x15, 0x92, 0x00, 0x1D, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xE0, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1D,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xE1, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x19, 0x59, 0x70, 0x32, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x13, 0x5D, 0x70, 0x2D, 0x5E,
	0x70, 0x11, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x40, 0x65, 0x70, 0x0B, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x07, 0x74, 0x70, 0x09, 0x75, 0x70, 0x08,
	0x81, 0x70, 0x0A, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#endif
#elif DDR3
	#if 0 /* BGA 243MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x85, 0x01, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x0A, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x44, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x13, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x50, 0x55, 0x70, 0x07, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x1E, 0x5A, 0x70, 0x0C, 0x5B, 0x70, 0x0C, 0x5D, 0x70, 0x1A,
	0x5E, 0x70, 0x12, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 267MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x6E, 0x01, 0x89, 0x00, 0x07, 0x8A,
	0x00, 0x0B, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x64, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x15, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0B, 0x55, 0x70, 0x08, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x21, 0x5A, 0x70, 0x0D, 0x5B, 0x70, 0x0D, 0x5D, 0x70, 0x1D,
	0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 297MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xBA, 0x03, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x8C, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF5, 0x55, 0x70,
	0x08, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 1 /* BGA 300MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xD7, 0x02, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x90, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0D, 0x55, 0x70,
	0x09, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 333MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xDD, 0x04, 0x89, 0x00, 0x09, 0x8A,
	0x00, 0x13, 0x92, 0x00, 0x17, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xBC, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1B,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0E, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x28, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x10, 0x5D, 0x70, 0x24, 0x5E,
	0x70, 0x14, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 360MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xA7, 0x05, 0x89, 0x00, 0x0A, 0x8A,
	0x00, 0x15, 0x92, 0x00, 0x1D, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xE0, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1D,
	0x6A, 0x70, 0xAE, 0x6B, 0x70, 0x0A, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xE1, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x2C, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x11, 0x5D, 0x70, 0x27, 0x5E,
	0x70, 0x15, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x05, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x0A, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 243MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x95, 0x01, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x0A, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x44, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x13, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x50, 0x55, 0x70, 0x07, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x1E, 0x5A, 0x70, 0x0C, 0x5B, 0x70, 0x0C, 0x5D, 0x70, 0x1A,
	0x5E, 0x70, 0x12, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 267MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x7E, 0x01, 0x89, 0x00, 0x07, 0x8A,
	0x00, 0x0B, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x64, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x15, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0B, 0x55, 0x70, 0x08, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x21, 0x5A, 0x70, 0x0D, 0x5B, 0x70, 0x0D, 0x5D, 0x70, 0x1D,
	0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 297MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xCA, 0x03, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x8C, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF5, 0x55, 0x70,
	0x08, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 300MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xE7, 0x02, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x90, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0D, 0x55, 0x70,
	0x09, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 333MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xED, 0x04, 0x89, 0x00, 0x09, 0x8A,
	0x00, 0x13, 0x92, 0x00, 0x17, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xBC, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1B,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0E, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x28, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x10, 0x5D, 0x70, 0x24, 0x5E,
	0x70, 0x14, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 360MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xB7, 0x05, 0x89, 0x00, 0x0A, 0x8A,
	0x00, 0x15, 0x92, 0x00, 0x1D, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xE0, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1D,
	0x6A, 0x70, 0xAE, 0x6B, 0x70, 0x0A, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xE1, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x2C, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x11, 0x5D, 0x70, 0x27, 0x5E,
	0x70, 0x15, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x05, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x0A, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#endif
#else
#error Both DDR2 and DDR3 are not defined.
#endif
};
#elif SPCA5330
const UINT8 dramParamData[] __attribute__ ((section (".bootParam"))) = {
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x41, 0x2C, 0x00, 0xCE, 0xEC, 0x6A, 0x70, 0xFF, 0x00,
	0x6B, 0x70, 0x0B, 0x00, 0x80, 0x70, 0x00, 0x00, 0x82, 0x70, 0x09, 0x00, 0x84, 0x70, 0xAA, 0x00,
	0x85, 0x70, 0xAA, 0x00, 0x86, 0x70, 0xAA, 0x00, 0x87, 0x70, 0x0A, 0x00, 0x88, 0x70, 0xAA, 0x00,
	0x89, 0x70, 0xAA, 0x00, 0x8A, 0x70, 0xAA, 0x00, 0x8B, 0x70, 0xAA, 0x00, 0x8C, 0x70, 0x00, 0x00,
	0x8D, 0x70, 0x00, 0x00, 0x8E, 0x70, 0x00, 0x00, 0x8F, 0x70, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00,
	0x20, 0x71, 0x40, 0x00, 0x50, 0x70, 0xD0, 0x00, 0x53, 0x70, 0x30, 0x00, 0x54, 0x70, 0x06, 0x00,
	0x55, 0x70, 0x04, 0x00, 0x56, 0x70, 0x03, 0x00, 0x57, 0x70, 0x41, 0x00, 0x58, 0x70, 0x15, 0x00,
	0x59, 0x70, 0x13, 0x00, 0x5A, 0x70, 0x06, 0x00, 0x5B, 0x70, 0x07, 0x00, 0x5D, 0x70, 0x11, 0x00,
	0x5E, 0x70, 0x0A, 0x00, 0x5F, 0x70, 0x11, 0x00, 0x64, 0x70, 0x30, 0x00, 0x65, 0x70, 0x05, 0x00,
	0x66, 0x70, 0x08, 0x00, 0x67, 0x70, 0x00, 0x00, 0x68, 0x70, 0x00, 0x00, 0x69, 0x70, 0x00, 0x00,
	0x73, 0x70, 0x04, 0x00, 0x74, 0x70, 0x07, 0x00, 0x75, 0x70, 0x07, 0x00, 0x81, 0x70, 0x0B, 0x00,
	0x83, 0x70, 0x00, 0x00, 0xE6, 0x70, 0x02, 0x00, 0x51, 0x70, 0x04, 0x00, 
};
#else
#error Both SPCA5330 and SPCA6330 are not defined.
#endif /* #elif SPCA5330 */

/**
 * \brief Fill the dram parameter for evb+romter
 *
 * In FPGA, we don't have to set the dram parameter.
 * In evb, if we use nand, the dram parameter is set by boot code.
 * Other cases - ram=1 or rom=1 that needs the romter, we have to set the
 * dram paramter here!
 */
static void
dramParam(
	void
)
{
	UINT32 i;
	UINT32 num;
	UINT32 sum, cks;
	UINT32 offset, value;
	UINT8 *ptr;
	volatile UINT8 *paddr;
	UINT8 *pparam = dramParamData;
	num = *((UINT16 *)(pparam + 8));
	cks = *((UINT16 *)(pparam + 10));
	sum = 0;
	ptr = pparam + 12;
	for (i = 0; i < num; i++) {
		#if SPCA6330
		offset = *ptr | (*(ptr+1) << 8);
		value = *(ptr + 2);
		ptr += 3;
		#else
		offset = *((UINT16 *)ptr);
		value = *((UINT16 *)(ptr+2));
		ptr += 4;
		#endif
		paddr = (volatile UINT8 *)(0xb0000000 + offset);
		*paddr = value;
		sum += offset;
		sum += value;
		#if 0
		QUART(offset, 4, 1);
		QUARTChar(' ');
		QUART(value, 4, 1);
		QUARTChar(' ');
		QUART(sum, 4, 1);
		QUARTChar(0xd);
		QUARTChar(0xa);
		#endif
	}
	while(!(*((UINT8 *)0xb00070f0) & 0x02));
	for(i=0;i<100000;i++);
	for(i=0;i<100000;i++);
	for(i=0;i<100000;i++);
	if ((UINT16)cks != (UINT16)sum) {
		QUARTChar('F');
		QUART(sum, 4, 1);
	}
}
#endif /* #if !defined(RAM_PROGRAM) && !defined(_FPGA_HW_) */


/** low level initialization function */
void
__init(
	void
)
{
	#ifndef RAM_PROGRAM
	UINT32 *src;
	#endif
	UINT32 *dst;
	UINT32 memSize;

	QUARTInit();

	QUARTChar('R');
	QUARTChar('O');
	QUARTChar('M');
	QUARTChar(' ');
	QUARTChar('O');
	QUARTChar('K');
	QUARTChar(0x0d);
	QUARTChar(0x0a);

	/* Enable Audio PLL */
	#if SPCA5330
	* ((volatile UINT8 *)0xb00000D0) = 0x01;
	#else
	* ((volatile UINT8 *)0xb0000074) = 0x01;
	#endif

	#if !defined(RAM_PROGRAM) && !defined(_FPGA_HW_)
  	dramParam();
	#endif

	memSize = dramSizeTest();

	/* Load the instructions or data onto DRAM */
	#ifndef RAM_PROGRAM
	#if 0
	src = memProfile.pdataLma;
	dst = memProfile.pdataVma;
	#else
	src = &_dram_content_lma_start;
	dst = &_dram_content_vma_start;
	#endif
	#if !defined(_FPGA_HW_) && defined(SPCA6330)
	UINT32 sum = 0;
	while ( dst < (UINT32 *)&_bssStart ) {
		*dst = *src;
		sum += *src;
		dst++;
		src++;
	}
	src = &_dram_content_lma_start;
	dst = &_dram_content_vma_start;
	while(dst < (UINT32 *)&_bssStart) {
		if (*dst != *src) {
			QUART(dst, 8, 1);
			QUARTChar('#');
			QUART(src, 8, 1);
			QUARTChar(':');
			QUART(*dst, 8, 1);
			QUARTChar('(');
			QUART(*src, 8, 1);
			QUARTChar(')');
			do {
				*((UINT32 *)(0x20000000 | (UINT32)dst))
					= *((UINT32 *)(0x20000000 | (UINT32)src));
			} while(*dst != *src);
			QUART(*dst, 8, 1);
			QUARTChar(0x0d);
			QUARTChar(0x0a);
		}
		dst++;
		src++;
	}
	#else
	while ( dst < (UINT32 *)&_bssStart ) {
		*dst = *src;
		dst++;
		src++;
	}
	#endif /* #if !defined(_FPGA_HW_) && defined(SPCA6330) */
	#endif

	/* Clear bss sections */
	dst = &_bssStart;
	while ( dst < &_bssEnd ) {
		*dst = 0;
		dst++;
	}
	memProfile.pheapStart = (void *)&_bssEnd + 1024; /* Leave 1KB for sbrk */
	memProfile.pheapEnd   = RAM_START_ADDR + memSize;
#if 0 /* updating with linker scripts lma -> vma */	   
	/* Solved the bug for 'If no '-O' in './app/Makefile', the firmware will not boot. This is happened in 'make ram=1'. */
	dst = (UINT32 *)0x80000080;
#if defined(_FPGA_HW_) && !defined(RAM_PROGRAM)
	src = (UINT32 *)0xbfc00080;
#else
	src = (UINT32 *)_exceptVect;
#endif /* #if defined(_FPGA_HW_) && !defined(RAM_PROGRAM) */
	if ( src != dst ) {
		for ( i = 0; i < 8; i++ ) {
			dst[i] = src[i];
		}
	}
#endif
	#if 0
	/* GPIO test */
	*((volatile UINT32 *)0xb0001034) = (UINT32)0x01;
	*((volatile UINT32 *)0xb0001030) = (UINT32)0x01;
	#endif
#if ISR_ON_IMEM  
	{
		extern void halCpuImemIsrRefill()
#if !ROM_PROGRAM && !RAM_PROGRAM
					__attribute__((far))
#endif /*#if !ROM_PROGRAM && !RAM_PROGRAM*/
					;
		halCpuImemIsrRefill();
	}
#endif /*#if ISR_ON_IMEM*/
	
}

/**************************************************************************
 *                                                                        *
 *  Function Name: __heapEndGet                                           *
 *                                                                        *
 *  Purposes: Get the memory address of heap's end.                       *
 *                                                                        *
 *  Limitations:                                                          *
 *                                                                        *
 *  Arguments: None                                                       *
 *                                                                        *
 *  Returns: None                                                         *
 *                                                                        *
 *  See also:                                                             *
 *                                                                        *
 **************************************************************************/
void *
__heapEndGet(
	void
)
{
	return memProfile.pheapEnd;
}
#else
#include "common.h"
#include "customization/solution_def.h"
#include "customization/dev_init.h"

/**************************************************************************
 *                           C O N S T A N T S                            *
 **************************************************************************/
#define RAM_START_ADDR 0xa0000000

/**************************************************************************
 *                              M A C R O S                               *
 **************************************************************************/

/**************************************************************************
 *                 E X T E R N A L    R E F E R E N C E S                 *
 **************************************************************************/
extern UINT32 _bssStart;
extern UINT32 _bssEnd __attribute__ ((section (".bss")));
extern void addrInit(void);
extern void _exceptVect(void);
extern UINT32 dramParam(void);

/**************************************************************************
 *                          D A T A    T Y P E S                          *
 **************************************************************************/
typedef struct memProfile_s {
	void *pdataLma;
	void *pdataVma;
	void *pheapStart;
	void *pheapEnd;
} memProfile_t;

/**************************************************************************
 *                         G L O B A L    D A T A                         *
 **************************************************************************/
memProfile_t memProfile __attribute__ ((section (".sbss")));
UINT32 maxSnapHeapSize;
#ifdef APPLOAD_FACETRACK
UINT32 appBufAddress;
UINT32 appBufSize=;
#endif
/**************************************************************************
 *               F U N C T I O N    D E C L A R A T I O N S               *
 **************************************************************************/
void   __init(void)       __attribute__ ((section (".boot")));
UINT32 dramSizeTest(void) __attribute__ ((section (".boot")));

/**************************************************************************
 *                                                                        *
 *  Function Name: dramSizeTest                                           *
 *                                                                        *
 *  Purposes: DRAM size detection.                                        *
 *                                                                        *
 *  Limitations:                                                          *
 *                                                                        *
 *  Arguments: None                                                       *
 *                                                                        *
 *  Returns: None                                                         *
 *                                                                        *
 *  See also:                                                             *
 *                                                                        *
 **************************************************************************/
UINT32
dramSizeTest(
	void
)
{
#if SPCA5310
	volatile UINT8  *preg = (UINT8 *)0xb0007050;
	/* DRAM size undetermined yet */
	#ifndef RAM_PROGRAM
	volatile UINT32 *pstart = (UINT32 *)RAM_START_ADDR;
	volatile UINT32 *pread;
	UINT32 i = 0x20;
	UINT32 j, k;
	UINT32 bits = 26/*unit:double-word*/, memSize = 256 * 1024 * 1024;/*unit:byte*/

	while ( i >= 1 ) {
		*preg = (*preg & 0xc0) | i;
		k = i;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			*pread = 0;
		}
		*pstart = 0xffffffff;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			if ( *pread == 0xffffffff ) {
				i=i>>1;
				bits--;
				memSize = memSize >> 1;
				break;
			}
		}
		if ( k == i ) {
			break;
		}
	}
	#else
	/* DRAM size determined in boot code earlier */
	UINT32 reg = (*preg & 0x3f)>>1;
	UINT32 memSize = 8 * 1024 * 1024;
	while ( reg ) {
		memSize = memSize * 2;
		reg=reg>>1;
	}
	#endif
#else /*SPCA5210*/
	volatile UINT8  *preg = (UINT8 *)0xb0007050;
	#ifndef RAM_PROGRAM
	volatile UINT32 *pstart = (UINT32 *)RAM_START_ADDR;
	volatile UINT32 *pread;
	UINT32 i = 6;
	UINT32 j, k;
	UINT32 bits = 25, memSize = 128 * 1024 * 1024;

	while ( i >= 3 ) {
		*preg = (*preg & 0xf8) | i;
		k = i;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			*pread = 0;
		}
		*pstart = 0xffffffff;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			if ( *pread == 0xffffffff ) {
				i--;
				bits--;
				memSize = memSize >> 1;
				break;
			}
		}
		if ( k == i ) {
			break;
		}
	}
	#else
	UINT32 reg = (*preg & 0x07) - 3;
	UINT32 memSize = 16 * 1024 * 1024;
	while ( reg ) {
		memSize = memSize * 2;
		reg--;
	}
	#endif
#endif/*SPCA5310*/

	#ifndef RAM_PROGRAM
	addrInit();
	#endif
	#if defined(_EVB_SPE7001_HW_) && DRAM_SIZE==0x200000
	if ( memSize >= 32*1024*1024 ) /* simulate limited memory in realkit */
		memSize = 32* 1024 * 1024;
	#endif
	return memSize;

}

/**************************************************************************
 *                                                                        *
 *  Function Name: __init                                                 *
 *                                                                        *
 *  Purposes: Low level initialization function.                          *
 *                                                                        *
 *  Limitations:                                                          *
 *                                                                        *
 *  Arguments: None                                                       *
 *                                                                        *
 *  Returns: None                                                         *
 *                                                                        *
 *  See also:                                                             *
 *                                                                        *
 **************************************************************************/
void
__init(
	void
)
{
	UINT32 *src;
	UINT32 *dst;
	UINT32 memSize, i;


	/* Enable Audio PLL */
	* ((volatile UINT8 *)0xb0000074) = 0x01;

	#ifndef RAM_PROGRAM
	#if !defined(_FPGA_HW_) && !defined(SPCA5210)
  	dramParam();
  	#endif
	#endif

	memSize = dramSizeTest();

	/* Load the instructions or data onto DRAM */
	src = memProfile.pdataLma;
	dst = memProfile.pdataVma;
	#ifndef RAM_PROGRAM
	while ( dst < (UINT32 *)&_bssStart ) {
		*dst = *src;
		dst++;
		src++;
	}
	#endif
	/* Clear .sbss and .bss section */
	dst = (UINT32 *)&_bssStart;
	while ( dst < (UINT32 *)&_bssEnd ) {
		*dst = 0;
		dst++;
	}
	memProfile.pheapStart = (void *)((UINT32 )&_bssEnd + 1024); /* Leave 1KB for sbrk */
#ifdef APPLOAD_FACETRACK
	memProfile.pheapEnd   = (void *)(RAM_START_ADDR + memSize - appBufSize);
	appBufAddress = ((UINT32)memProfile.pheapEnd) & ~0x20000000;
#else	
	memProfile.pheapEnd   = (void *)(RAM_START_ADDR + memSize);
#endif

	/* Solved the bug for 'If no '-O' in './app/Makefile', the firmware will not boot. This is happened in 'make ram=1'. */
	dst = (UINT32 *)0x80000080;
#if defined(_FPGA_HW_) && !defined(RAM_PROGRAM)
	src = (UINT32 *)0xbfc00080;
#else
	src = (UINT32 *)_exceptVect;
#endif /* #if defined(_FPGA_HW_) && !defined(RAM_PROGRAM) */
	if ( src != dst ) {
		for ( i = 0; i < 8; i++ ) {
			dst[i] = src[i];
		}
	}
#if ISR_ON_IMEM  
	{
		extern void halCpuImemIsrRefill()
#if !ROM_PROGRAM && !RAM_PROGRAM
					__attribute__((far))
#endif /*#if !ROM_PROGRAM && !RAM_PROGRAM*/
					;
		halCpuImemIsrRefill();
	}
#endif /*#if ISR_ON_IMEM*/

}

/**************************************************************************
 *                                                                        *
 *  Function Name: __heapEndGet                                           *
 *                                                                        *
 *  Purposes: Get the memory address of heap's end.                       *
 *                                                                        *
 *  Limitations:                                                          *
 *                                                                        *
 *  Arguments: None                                                       *
 *                                                                        *
 *  Returns: None                                                         *
 *                                                                        *
 *  See also:                                                             *
 *                                                                        *
 **************************************************************************/
void *
__heapEndGet(
	void
)
{
	return memProfile.pheapEnd;
}

#endif

