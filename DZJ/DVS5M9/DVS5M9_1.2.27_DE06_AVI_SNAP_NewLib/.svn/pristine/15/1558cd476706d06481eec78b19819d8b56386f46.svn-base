/**************************************************************************
 *                                                                        *
 *         Copyright (c) 2010 by DXG Technology Co., Ltd.             *
 *                                                                        *
 *  This software is copyrighted by and is the property of DXG        *
 *  Technology Co., Ltd. All rights are reserved by DXG Technology    *
 *  Co., Ltd. This software may only be used in accordance with the       *
 *  corresponding license agreement. Any unauthorized use, duplication,   *
 *  distribution, or disclosure of this software is expressly forbidden.  *
 *                                                                        *
 *  This Copyright notice MUST not be removed or modified without prior   *
 *  written consent of DXG Technology Co., Ltd.                       *
 *                                                                        *
 *  DXG Technology Co., Ltd. reserves the right to modify this        *
 *  software without notice.                                              *
 *                                                                        *
 *  DXG Technology Co., Ltd.                                          *
 *  MIN ZHI IND., PARK,					            *
 *  LONG HUA,BAOAN,SHEN ZHEN,P.R.O.C.                                           *
 *                                                                        *
 *  Author:                                              *
 *                                                                         *
 **************************************************************************/
 
//#include "../../sphost/customization/hostfw/include/app_buzzer.h"
//#include "app_osd_api_lcm.h"
//#include "app_osd_draw_lcm.h"

//#include "middleware/global_def.h"

#if 0
#include "../../sphost/customization/hostfw/include/App_timer.h"
#include "../../sphost/customization/hostfw/cathyware/inc/net/Ndk_types.h"


#include "../../sphost/customization/hostfw/include/app_ui_para.h"
#include "../../sphost/customization/hostfw/include/app_key_def.h"
#include "../../sphost/customization/hostfw/include/App_state_ctrl.h"
#include "../../sphost/customization/hostfw/include/App_scdv_ui_para_def.h"
#endif
//#include "../../sphost/customization/hostfw/include/App_ui_para_dvs5m2.h"
#include "common.h"
#include "api/cmd.h"
#include "stdlib.h"
#include "string.h"
#include "api/sp5k_utility_api.h"
#include "api/sp5k_global_api.h"
#include "api/sp5k_os_api.h"
#include "api/sp5k_capture_api.h"
#include "api/sp5k_fs_api.h"
#include "../../sphost/include/rf/app_rf_def.h"

//typedef struct uiPara_s uiPara_t;
//typedef  UINT8  UINT8;
//typedef  UINT16  UINT16;	
//typedef  UINT32  UINT32;	
//extern uiPara_t* appUiParaGet(void);
#define    APP_UI_MSG_RF_REC			0xFB090001		
#define 	APP_UI_MSG_RF_SNAP			0xFB090002
	
#define RFMODE_SPI  SP5K_SPI_CLK_IDLE_LOW_LATCH_RISE   //0x0
#define RF_FERQUENCY_SPI  SP5K_GSI_CLK_DIVISOR_128

#define RF2401_RF_RX_SCAN_RATE 	10 ///1ms
// CS must be controlled by host
#define RFHW_POWER   	(1<<2)
#define RFHW_CE    		(1<<4)  		//gpio4  gen
#define RFHW_IRQ      		(1<<13)   	//gpio13 
#define RFHW_CSN  		(1<<0)  		//LMI0  LMIGPIO0

#define RFHW_CLK  		1<<(48-32)    //FMGPIO48
#define RFHW_MISO   		1<<(47-32)   //FMGPIO47  FMH
#define RFHW_MOSI	 	1<<(49-32)   //FMGPIO49  FMH

#define CSN(x);    sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RFHW_CSN,x<<0);
#define CSN(x);    sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RFHW_CSN,x<<0);


#define RF2401_SPI_ID		(1)
#define RF2401_SPI_DFS 	(0x7)

#define RF2401_SPI_CSN_GPIO	

// nRF2401 RegMap  define
#define NRF_RF_CONFIG			(0x00)
#define NRF_EN_AA				(0x01)
#define NRF_EN_RXADDR			(0x02)
#define NRF_SETUP_AW			(0x03)
#define NRF_SETUP_RETR			(0x04)
#define NRF_RF_CH				(0x05)
#define NRF_RF_SETUP			(0x06)
#define NRF_RF_STATUS			(0x07)
#define NRF_OBSERVE_TX			(0x08)
#define NRF_RF_PRD				(0x09)
#define NRF_RX_ADDR_P0			(0x0A)
#define NRF_RX_ADDR_P1			(0x0B)
#define NRF_RX_ADDR_P2			(0x0C)
#define NRF_RX_ADDR_P3			(0x0D)
#define NRF_RX_ADDR_P4			(0x0E)
#define NRF_RX_ADDR_P5			(0x0F)
#define NRF_TX_ADDR				(0x10)
#define NRF_RX_PW_P0			(0x11)
#define NRF_RX_PW_P1			(0x12)
#define NRF_RX_PW_P2			(0x13)
#define NRF_RX_PW_P3			(0x14)
#define NRF_RX_PW_P4			(0x15)
#define NRF_RX_PW_P5			(0x16)
#define NRF_FIFO_STATUS			(0x17)
#define NRF_DYNPD				(0x1C)
#define NRF_FEATURE				(0x1D)


// 24L01plus Register Map 
#define CONFIG_MAP 			0x00
#define EN_AA_MAP 			0x01
#define EN_RXADDR_MAP 		0x02
#define SETUP_AW_MAP		0x03
#define SETUP_RETR_MAP 	0x04
#define RF_CH_MAP 			0x05
#define RF_SETUP_MAP 		0x06
#define STATUS_MAP 			0x07
#define OBSERVE_TX_MAP 	0x08
#define RPD_MAP 			0x09
#define RX_ADDR_P0_MAP 	0x0A
#define RX_ADDR_P1_MAP 	0x0B
#define RX_ADDR_P2_MAP 	0x0C
#define RX_ADDR_P3_MAP 	0x0D
#define RX_ADDR_P4_MAP 	0x0E
#define RX_ADDR_P5_MAP 	0x0F
#define TX_ADDR_MAP 		0x10
#define RX_PW_P0_MAP 		0x11
#define FIFO_STATUS_MAP 	0x17
#define DYNPD_MAP 			0x1C
#define FEATURE_MAP 		0x1D

// Nordic Command
#define NRF_R_REGISTER					0x00
#define NRF_W_REGISTER					0x20
#define NRF_R_RX_PAYLOAD				0x61
#define NRF_W_TX_PAYLOAD				0xA0
#define NRF_FLUSH_TX					0xE1
#define NRF_FLUSH_RX					0xE2
#define NRF_REUSE_TX_PL				0xE3
#define NRF_ACTIVATE					0x50
#define NRF_R_RX_PL_WID				0x60
#define NRF_W_ACK_PAYLOAD				0xA8
#define NRF_W_TX_PAYLOAD_NO_ACK		0xB0
#define NOP         							0xFF  
//----------------------------------
#define RF_TRANSMIT_MODE			(0x5e) 	//01011110b
#define RF_RECEIVE_MODE			(0x3f)	//00111111b
#define RF_CHIP_POWER_OFF			(0x7c)	//01111100b
#define RECEIVE_PAYLOAD			8
#define TEST_TX_PAYLOAD			32
#define RF_PIPE_0					0x00
 
#define CUSTOMER_ADDR0	(0x08)	//CUID code
#define CUSTOMER_ADDR1	(0x08)
#define CUSTOMER_ADDR2	(0x08)
#define CUSTOMER_ADDR3	(0x09) 	//week
#define CUSTOMER_ADDR4	(0x0b) 	//year
	
 //pair mode addr
#define PARN_ADDR0			(0x96)
#define PARN_ADDR1			(0x69)
#define PARN_ADDR2			(0x96)
#define PARN_ADDR3			(0x69)
#define PARN_ADDR4			(0x5A)

 

//return( un access) code ,pair fail 
#define  PARN_FAIL_CODE0	(0xFA)  
#define  PARN_FAIL_CODE1	(0xFA)  
#define  PARN_FAIL_CODE2	(0xFA)  
#define  PARN_FAIL_CODE3	(0xFA)  //week
#define  PARN_FAIL_CODE4	(0xFA)  //year


//Camera Current  Status 
enum {
	CAMST_IDLE=0, 
	CAMST_PRV, CAMST_REC, CAMST_CAP, CAMST_STOP, 
	CAMST_WIFI_PRV,  CAMST_WIFI_REC,CAMST_WIFI_CAP
};

//Camera Error Code
enum{
	CAMERR_OK=0,  CAMERR_BUSY,
	CAMERR_CARD_FULL, CAMERR_BATLOW, CAMERR_TIMEOUT,	
};


#define RF2401_RF_TASK_EN   0  		// RF2401_RF_RX_IRQ sube 1,     0: use Timer polling.
#define FCT_RC_PAYLOAD_CB
#define RF2401_RF_RX_IRQ	0   		//0: using polling mode , 1: as interrupt mode.

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
enum {MD_RX=0,  MD_TX};
enum {GPIOSPI=0,HWSPI=1,};
static UINT8  nRFMode=0;				//0: as RX / 1: as TX mode
static UINT8 *pRPLdata=NULL;
static UINT8 	nRFSpiMode=HWSPI;		//0: SPI H/W interface, 1: use Gpio function.
static UINT8 	nRFSpiShiftByteLen=7;		//7: work bfs = 8bits
static UINT8 nRFInitDone=0;
static UINT8 nRFParingMode=0;

static UINT8 nRFRegCtx[32]={0};
static UINT8 gRF24Init=0;

//nRF_Par_Ch_tab
static UINT8 nRFParCHTab[2]={1,79};  //paring 2401Mhz or 2479Mhz

#define  	FREQ_HOP_GRP  0x0// 0x01  0x02 0x03
#define 	FREQ_HOP  1

static UINT8 nRFFreqHopTab[4][4]={

	#ifdef FREQ_HOP
		{ 3 , 41, 77, 41},
		{ 41, 3, 77, 3},
		{ 77 , 41, 77, 3},
		{ 3 , 77, 3, 41},
	#else
		{ 41 , 41, 41, 41},
		{ 41, 41,41, 41},
		{ 41 , 41, 41, 41},
		{ 41 , 41, 41, 41},
	#endif
};
 

#define SPI_READ_BUF_SIZE			(32)
#define HW_SPI_DELAY  1
enum {START_RECORD=0x01,STOP_RECORD=0x05,SNAP=0x02,REQUEST_SATUS=0xFC };


//UINT32 RFTimerHand = TIMER_NULL;
static TX_THREAD *pThreadRFSend = NULL;
static TX_THREAD *pThreadRFReceive = NULL;
UINT8 PingPongCH= 1;

int printf(const char *format, ...);
 void RFCELOW();
 void RFCEHIGH();
 void spi_delay_task(UINT16 n);
 //extern UINT8* appUiCUIDParacGet(void);
UINT8 ReadPLData[32] = {0};
//UINT8 *ReadPLData = NULL;

//UINT32 wt_config_cuid_num = 0x015B38;
UINT32 nPairRandomCUID = 0x015B38;
struct tDxgCuid{UINT8 Year;UINT8 Week;}  DateCUID={14,33};
static UINT8 CamStatus=0;
static UINT8 CamErrorCode=0;
static UINT16 CamFileNum=0;
UINT8 ReadPLDataBack[32];
UINT8 nRfSwich=0;
UINT8  nPairAddrEnable=0;
/////////////////////HW SPI Driver Begin///////////////
static void HWSPIInit()
{
		//RF_POWER
		sp5kGpioFuncSet(SP5K_GPIO_GRP_GEN,RFHW_POWER,1<<2);
		sp5kGpioCfgSet(SP5K_GPIO_GRP_GEN,RFHW_POWER,1<<2);		
		sp5kGpioPullSet(SP5K_GPIO_GRP_GEN,RFHW_POWER,1<<2);
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RFHW_POWER,1<<2);//init 0 or 1
		spi_delay_task(1000);

		//CE
		sp5kGpioCfgSet(SP5K_GPIO_GRP_GEN,RFHW_CE,1<<4);
		sp5kGpioPullSet(SP5K_GPIO_GRP_GEN,RFHW_CE,1<<4);
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RFHW_CE,0<<4);//init 0 or 1

		//IRQ
		sp5kGpioCfgSet(SP5K_GPIO_GRP_GEN,RFHW_IRQ,0<<13);
		sp5kGpioPullSet(SP5K_GPIO_GRP_GEN,RFHW_IRQ,1<<13);
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RFHW_IRQ,1<<13);//init 0 or 1

		//CSN
		sp5kGpioCfgSet(SP5K_GPIO_GRP_LMI,RFHW_CSN,1<<0);
		sp5kGpioPullSet(SP5K_GPIO_GRP_LMI,RFHW_CSN,1<<0);
		sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RFHW_CSN,1<<0);//init 0 or 1

		
		
}

void gRFDriverInit()
{
	sp5kSscCfgSet(SP5K_SSC_PORT_3, SP5K_SSC_CFG_MODE, SP5K_SSC_MODE_SPI);
	sp5kSscCfgSet(SP5K_SSC_PORT_3, SP5K_SSC_CFG_PIN, SP5K_SSC_CFG_SSC1_PIN1 );
	sp5kSscCfgSet(SP5K_SSC_PORT_3, SP5K_GSI_CFG_PHY, (RFMODE_SPI << 16 | RF_FERQUENCY_SPI << 8));

}
void appSpiWriteData(UINT8 *pData, UINT8 len)
{
	//gRFDriverInit();
	UINT8 nBitCount=0;
	nBitCount = len*8;
	CSN(0);		
	sp5kSpiWrite(SP5K_SSC_PORT_3, pData, nBitCount);//bitcnt
	CSN(1);
}

//write reg and value for 1bytes  command word
void appSpiWriteCmd(UINT8 nCmdName, UINT8 nCmdWord)
{
	//gRFDriverInit();
	UINT8 nBitCount=0;
	UINT8 nCmdBuffer[2];
	nCmdBuffer[0]=nCmdName|NRF_W_REGISTER;
	nCmdBuffer[1]=nCmdWord;
	nBitCount = 2*8;
	CSN(0);		
	sp5kSpiWrite(SP5K_SSC_PORT_3, nCmdBuffer, nBitCount);//bitcnt
	CSN(1);
}

UINT8 appSpiReadCmd(UINT8 reg,UINT8 nlen)
{
	//gRFDriverInit();
	
	CSN(0);
	sp5kSpiWrite(SP5K_SSC_PORT_3, &reg, 8);//bitcnt		
	sp5kSpiRead(SP5K_SSC_PORT_3, ReadPLData, 8*nlen);
	CSN(1);
	return ReadPLData[0];
}
//p0 addr 5 byte lsb byte c
void appSpiFlushTxFifo()
{
	UINT8 nBitCount=0;
	UINT8 nCmdBuffer[2];
	nCmdBuffer[0]=NRF_FLUSH_TX;
	nCmdBuffer[1]=0;		
	appSpiWriteData(nCmdBuffer, 1);
	
}
void appSpiFlushRxFifo()
{
	UINT8 nBitCount=0;
	UINT8 nCmdBuffer[2];
	nCmdBuffer[0]=NRF_FLUSH_RX;
	nCmdBuffer[1]=0;		
	appSpiWriteData(nCmdBuffer, 1);

}

void appSpiWriteBurstData(UINT8 *pData, UINT8 len)
{
	UINT8 nCmdBuffer[33],i=0;
	nCmdBuffer[0]=NRF_W_TX_PAYLOAD;
	for(i=0;i<len;i++)
		nCmdBuffer[i+1]=pData[i];
	//memcpy(nCmdBuffer+1,pData,len);
	appSpiWriteData(nCmdBuffer, len+1);
}
void appSpiReadBurstData(UINT8 nPipe)
{

	UINT8 len=0;
	len=appSpiReadCmd(NRF_RX_PW_P0|nPipe,1);//p0=p5
	appSpiReadCmd(NRF_R_RX_PAYLOAD,len);
	
}

void appSpiWriteACKPayload(UINT8 nPipe,UINT8 *pData, UINT8 len)
{
	UINT8 nCmdBuffer[33],i=0;
	nCmdBuffer[0]=NRF_W_ACK_PAYLOAD|nPipe;//0-5
	for(i=0;i<len;i++)
		nCmdBuffer[i+1]=pData[i];
	//memcpy(nCmdBuffer+1,pData,len);
	appSpiWriteData(nCmdBuffer, len+1);

}

void TestHWSpi()
{
	UINT8  i=0;
	UINT8 Buf[6]={
		NRF_RX_ADDR_P0|NRF_W_REGISTER,  //byte0
		0x90,
		0x90,
		0x90,
		0x90,
		0x88
		};
	printf("TestHWSpi\n");
	
	HWSPIInit();
	gRFDriverInit();
	
	RFCELOW();
	appSpiWriteData(Buf,6);
	Buf[0]=NRF_TX_ADDR|NRF_W_REGISTER;
	appSpiWriteData(Buf,6);

	appSpiReadCmd(NRF_TX_ADDR,5);
	//for(i=0;i<5;i++)
	printf("TX Addr=0x%x 0x%x 0x%x 0x%x 0x%x\n ",ReadPLData[0],ReadPLData[1],ReadPLData[2],ReadPLData[3],ReadPLData[4]);
	ReadPLData[0]=0x77;
	appSpiReadCmd(NRF_RX_ADDR_P0,5);
	//for(i=0;i<5;i++)
	printf("RX Addr=0x%x 0x%x 0x%x 0x%x 0x%x\n ",ReadPLData[0],ReadPLData[1],ReadPLData[2],ReadPLData[3],ReadPLData[4]);
	

	appSpiWriteCmd(NRF_RF_SETUP,0x06);
	appSpiReadCmd(NRF_RF_SETUP,1);
	printf("setup =%d\n",ReadPLData[0]);		
	appSpiReadCmd(STATUS_MAP,1);
	printf("status =%d\n",ReadPLData[0]);	
		
	RFCEHIGH();
	//extern UINT32 previewCallbackTest(void);
	//previewCallbackTest();
	

}

// lock embedded SPI engine, no storage access allowed after this
// note that SP5K_SSC_LOCK is costy so host should use larger granularity
//sp5kSscCfgSet(SP5K_SSC_PORT_2, SP5K_SSC_LOCK, 1);
//sp5kSpiWrite(APP_SPI_PORT|SP5K_PORT_MASK_DMA_MODE, data, byteCnt*8); // note that sp5kSpiWrite use bit count	
// release embedded SPI engine, storage access is OK now
//sp5kSscCfgSet(SP5K_SSC_PORT_2, SP5K_SSC_LOCK, 0);

/////////////////////	HW SPI Driver End		///////////////


void spi_delay_task(UINT16 n)
{	
	UINT16 i=0;
	#ifdef HW_SPI_DELAY
		for(i=0; i<n;i++)
		sp5kTimeDelay(SP5K_TIME_DELAY_1US ,1);
	#else	 
			i=1000; 
			while(i--);   
	#endif
}
 

//===================================================================
void nRF2401_MemoryInit(void)
{	

	printf("nRF2401 mem init...\n");
	if (pRPLdata == NULL)
		pRPLdata = sp5kMalloc(SPI_READ_BUF_SIZE * 2)	;				
	//printf("PayLoad Heap buffer error!!!\n");
	
}

#define RF_POWER   1<<2
#define RF_CE    (1<<4)  		//gpio4  gen
#define RF_CSN  (1<<13)  		//GPIO13    AUDCLKO/E11

#define RF_CLK  (1<<0)   		//LMI0  LMIGPIO0
#define RF_MISO   1<<(49-32)   //FMGPIO49  FMH
#define RF_MOSI	 1<<(48-32)    //FMGPIO48
#define RF_IRQ      1<<(47-32)   //FMGPIO47 

static void GpioSPIInit(UINT8  en)
{
	if(en)
	{
		//RF_POWER
		sp5kGpioFuncSet(SP5K_GPIO_GRP_GEN,RF_POWER,1<<2);
		sp5kGpioCfgSet(SP5K_GPIO_GRP_GEN,RF_POWER,1<<2);		
		sp5kGpioPullSet(SP5K_GPIO_GRP_GEN,RF_POWER,1<<2);
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_POWER,1<<2);//init 0 or 1
		spi_delay_task(1000);
		//CE
		sp5kGpioCfgSet(SP5K_GPIO_GRP_GEN,RF_CE,1<<4);
		sp5kGpioPullSet(SP5K_GPIO_GRP_GEN,RF_CE,1<<4);
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CE,0<<4);//init 0 or 1

		//CSN
		sp5kGpioCfgSet(SP5K_GPIO_GRP_GEN,RF_CSN,1<<13);
		sp5kGpioPullSet(SP5K_GPIO_GRP_GEN,RF_CSN,1<<13);
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CSN,1<<13);//init 0 or 1

		//CLK
		sp5kGpioCfgSet(SP5K_GPIO_GRP_LMI,RF_CLK,1<<0);
		sp5kGpioPullSet(SP5K_GPIO_GRP_LMI,RF_CLK,1<<0);
		sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RF_CLK,1<<0);
		
					
		//MISO
		sp5kGpioCfgSet(SP5K_GPIO_GRP_FMH,RF_MISO,0<<(49-32));
		sp5kGpioPullSet(SP5K_GPIO_GRP_FMH,RF_MISO,1<<(49-32));
		sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MISO,1<<(49-32));

		//MOSI
		sp5kGpioCfgSet(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
		sp5kGpioPullSet(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
		sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
	
		//IRQ
		sp5kGpioCfgSet(SP5K_GPIO_GRP_FMH,RF_IRQ,0<<(47-32));
		sp5kGpioPullSet(SP5K_GPIO_GRP_FMH,RF_IRQ,1<<(47-32));
					
	}
	else
	{
		//gpio_config(GPIO_RF2401_CSN, GPIO_FUNC_HW);
		//gpio_config(GPIO_RF2401_CLK, GPIO_FUNC_HW);
		//gpio_config(GPIO_RF2401_MOSI, GPIO_FUNC_HW);
		//gpio_config(GPIO_RF2401_MISO, GPIO_FUNC_HW);		
	}
	
}
static void vGpioRF_Init()
{
		//MISO
		sp5kGpioCfgSet(SP5K_GPIO_GRP_FMH,RF_MISO,1<<(49-32));
		sp5kGpioPullSet(SP5K_GPIO_GRP_FMH,RF_MISO,1<<(49-32));
		sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MISO,1<<(49-32));

		//MOSI
		sp5kGpioCfgSet(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
		sp5kGpioPullSet(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
		sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MOSI,0<<(48-32));
	
		//IRQ
		sp5kGpioCfgSet(SP5K_GPIO_GRP_FMH,RF_IRQ,0<<(47-32));
		sp5kGpioPullSet(SP5K_GPIO_GRP_FMH,RF_IRQ,1<(47-32));



}
//RFCEHIGH
 void RFCEHIGH()
{
		
	sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CE,1<<4);
	//printf("--ce high\n");
	
}
//RFCELOW
 void RFCELOW()
{
			
	sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CE,0<<4);
	//printf("--ce low\n");
	
}

static void vGpioRF_CsnSetHigh()
{
	sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CSN,1<<13);
	//printf("--csn high\n");

}
static void vGpioRF_CsnSetLow()
{
	sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CSN,0<<13);
	//printf("--csn low\n");

}

static void vGpioRF_sckSetHigh()
{
	sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RF_CLK,1<<0);
	//printf("--clk high\n");

}
static void vGpioRF_sckSetLow()
{
	sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RF_CLK,0<<0);
	//printf("--clk low\n");

}

static void vGpioRF_MosiSetHigh()
{
	sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
	//printf("--mosi high\n");

}
static void vGpioRF_MosiSetLow()
{
	sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MOSI,0<<(48-32));
	//printf("--mosi low\n");

}
static void GpioSpiCSN(UINT8 nPinLevel)
{
	if(nPinLevel){		
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CSN,1<<13);
	}else{		
		sp5kGpioWrite(SP5K_GPIO_GRP_GEN,RF_CSN,0<<13);
	}
	//printf("--csn=%d\n",lv);
}


static void GpioSpiCLK(UINT8 nPinLevel)
{
	if(nPinLevel){
		sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RF_CLK,1<<0);
	}else{
		sp5kGpioWrite(SP5K_GPIO_GRP_LMI,RF_CLK,0<<0);
	}
}

static void GpioSpiMOSI(UINT8 nPinLevel)
{
	if(nPinLevel){
		sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MOSI,1<<(48-32));
	}else{
		sp5kGpioWrite(SP5K_GPIO_GRP_FMH,RF_MOSI,0<<(48-32));
	}
}

 
static UINT32 GpioSpiMISO(void)
{
	UINT32 nPinLevel=0;	
	sp5kGpioRead(SP5K_GPIO_GRP_FMH, RF_MISO, &nPinLevel);
	if(nPinLevel) nPinLevel=1;
	else nPinLevel=0;
	//printf("miso=%d\n",lv);
	return(nPinLevel);
}


static UINT32 GetRF_IRQLevel(void)
{
	UINT32 nPinLevel=0;	
	if(nRFSpiMode==GPIOSPI)
		sp5kGpioRead(SP5K_GPIO_GRP_FMH, RF_IRQ, &nPinLevel);
	else
		sp5kGpioRead(SP5K_GPIO_GRP_GEN, RFHW_IRQ, &nPinLevel);
	
	if(nPinLevel) nPinLevel=1;
	else nPinLevel=0;
	//printf("irq=%d\n",lv);
	return(nPinLevel);
}

static void GpioSpiDLY(UINT16 dly)
{
	int i,j;
	for(i=0;i<dly;i++){
		for(j=0;j<10;j++);
	}
}


static void GpioSpiWrite(UINT16 id, UINT8 *ptr, UINT8 len)
{
	int btn;
	int i;
	UINT8 dat;
	UINT8 dat_in;
	
	GpioSpiCLK(0);
	GpioSpiCSN(0);
	GpioSpiDLY(10);
	for(i=0;i<len;i++){
		dat = ptr[i];
		dat_in=0;
		for(btn=0;btn<=nRFSpiShiftByteLen;btn++){
			GpioSpiMOSI(dat&0x80);
			dat<<=1;
			GpioSpiDLY(1);
			GpioSpiCLK(1);
			dat_in<<=1;
			dat_in |=  (GpioSpiMISO())?(0x01):(0x00);			
			GpioSpiDLY(1);
			GpioSpiCLK(0);
		}
		ReadPLData[i]=dat_in;
	}

	GpioSpiCLK(0);
	GpioSpiCSN(1);
}

static void RFWriteDat(UINT8 cmd,UINT8 *ptr, UINT8 len)
{
	int i;
	static UINT8 Buf[32];
	
	Buf[0]= cmd ;//0x1234;

	if(len>31) 
		len=31;
	for(i=0;i<len;i++)
	{
		Buf[i+1]=ptr[i];
	}

	if(nRFSpiMode==GPIOSPI) 
	{
		GpioSpiWrite(RF2401_SPI_ID,Buf,len+1);
	}	
	else	
	{	      
		appSpiWriteData(Buf,len+1);   
	}
	
	

}
static void RFWriteCmd(UINT8 adr,UINT8 Data)
{

	nRFRegCtx[adr]=(UINT8)Data;
	adr=adr |NRF_W_REGISTER;

	RFWriteDat(adr,&Data,1);
}

static void RFClearIrq(void)
{
	RFWriteCmd(NRF_RF_STATUS,0x70);  		// Enable ACK Pipe-0
	spi_delay_task(2);
}

static void RFTxFlushFIFO(void)
{
	RFWriteDat(NRF_FLUSH_TX,NULL,0);     
}

static void RFRxFlushFIFO(void)
{
	RFWriteDat(NRF_FLUSH_RX,NULL,0);            
}
static void RFSetup(UINT8 dat)
{      
	RFWriteCmd(NRF_RF_SETUP,dat);
}

#define RFADDREN	(5)

static void RFSetTxAddr(UINT8 *adr, UINT8 updAdr)
{
	int i;
	UINT8 Buf[RFADDREN]={		 
		0x90,
		0x90,
		0x90,
		0x90,
		0x5A
		};
	
	if(updAdr)
	{		
		for(i=0;i<5;i++)
		{
			Buf[i] = adr[i];
		}
	}
	RFWriteDat(NRF_TX_ADDR|NRF_W_REGISTER,Buf,RFADDREN);
}       

//p0 addr 5 byte lsb byte first  
static void RFSetRxAddr(UINT8 *adr, UINT8 updAdr)
{
	int i;	
	UINT8 Buf[RFADDREN]={		 
		0x90,
		0x90,
		0x90,
		0x90,
		0x5A
		};
	if(updAdr){		
		for(i=0;i<5;i++){
			Buf[i] = adr[i];
		}
	}
	RFWriteDat(NRF_RX_ADDR_P0|NRF_W_REGISTER,Buf,RFADDREN);
       
}


//Function: Write Read command. write 1 byte then receiver len of requestion RX

static UINT8 RFReadWriteCmd(UINT8 adr,  UINT8 len)//p0 6
{
	UINT8 Buf[32];
	int i;
	
	Buf[0]= adr ;
	
	if(nRFSpiMode==GPIOSPI) 
	{
		GpioSpiWrite(RF2401_SPI_ID,Buf,len+1);
		for(i=0;i<len;i++)
		{
			pRPLdata[i]=  ReadPLData[i+1]; //rdata init malloc heap memory
		}
	}
	else
	{				
			appSpiReadCmd(adr,len);
			for(i=0;i<len;i++)
			{
				pRPLdata[i]=  ReadPLData[i]; //rdata init malloc heap memory
			}
	}
	
	//return ((nRFSpiMode==GPIOSPI)?(pRPLdata[1]):(pRPLdata[0])); 
	return pRPLdata[0];
}


//  prepare nRF2401 TX and RX Adress( CUID) .
//  NO CUID nPairRandomCUID = 0 
// Notes:   Adrress need rev argment

static void RFSetTXRXAddr(void)
{
		
		UINT8 Buf[5];
				
		int i;
		i=0;

		if(nRFParingMode)
		{
			
			Buf[i++]= PARN_ADDR0;//0x96  lsb
			Buf[i++]= PARN_ADDR1;//0x69
			Buf[i++]= PARN_ADDR2;//0x96
			Buf[i++]= PARN_ADDR3;//0x69
			Buf[i++]= PARN_ADDR4;//0x5a
			
			printf("set paring mode Adr....\n");
			
		}
		else if(nPairRandomCUID>=1 && nPairRandomCUID<=99999  )
		{
			Buf[i++]= DateCUID.Year;
			Buf[i++]= DateCUID.Week;
			Buf[i++]= (UINT8)(((nPairRandomCUID>>16)&0x00ffL)  );
			Buf[i++]= (UINT8)((nPairRandomCUID>>8)&0x00ffL);
			Buf[i++]= (UINT8)(nPairRandomCUID&0x00ffL);
			printf("CUID= %d\n",nPairRandomCUID);
		}
		else
		{
			//if NO CUID, default ID value  A9876
			Buf[i++]= CUSTOMER_ADDR0;
			Buf[i++]= CUSTOMER_ADDR1;
			Buf[i++]= CUSTOMER_ADDR2;
			Buf[i++]= CUSTOMER_ADDR3;
			Buf[i++]= CUSTOMER_ADDR4;
			printf("Warning!! NO CUID= %d\n",nPairRandomCUID);
		}
		
		spi_delay_task(1);
		RFSetTxAddr(Buf,1);
		spi_delay_task(1);
		RFReadWriteCmd( NRF_TX_ADDR,5);
		printf("NRF_TX_ADDR11 =0x%x 0x%x 0x%x 0x%x 0x%x\n",pRPLdata[0],pRPLdata[1],pRPLdata[2],pRPLdata[3],pRPLdata[4]);
		spi_delay_task(1);		
		RFSetRxAddr(Buf,1);		
		spi_delay_task(1);
		RFReadWriteCmd( NRF_RX_ADDR_P0,5);
		printf("NRF_RX_ADDR_P01 =0x%x 0x%x 0x%x 0x%x 0x%x\n",pRPLdata[0],pRPLdata[1],pRPLdata[2],pRPLdata[3],pRPLdata[4]);
		//spi_delay_task(1);		
		//RFReadWriteCmd( NRF_RF_SETUP,1);
		//printf("NRF_RF_SETUP1=0x%x \n",pRPLdata[1]);
		//printf("nRF2401 TX RX Adr ==0x%x 0x%x 0x%x 0x%x 0x%x\n",Buf[0],Buf[1],Buf[2],Buf[3],Buf[4]);

}

//Set TX RX Frequency (Channel) From 2401~2483Mhz

static void RFChgTXRXCh(UINT8 nChIdx)
{
	UINT8 nCh;

	if(nRFParingMode)
	{
		nCh = nRFParCHTab[nChIdx&0x01];
	}
	else
	{
		nCh = nRFFreqHopTab[FREQ_HOP_GRP&0x03][nChIdx&0x03];
	}
	
	RFCELOW();
	RFWriteCmd(NRF_RF_CH,nCh);
	RFCEHIGH();
	
	//printf("Change Ch=%d\n",nCh);
}

//vdxgapp_nRF2401_Init
void RF2401Init(void)
{
    
	
	if(nRFSpiMode==GPIOSPI)	
	{
		GpioSPIInit(1);
	}	
	else
	{
		HWSPIInit();
		gRFDriverInit();
	}
#if 1
	RFCELOW();	
	spi_delay_task(1);
	RFClearIrq();
	spi_delay_task(1);
	RFTxFlushFIFO();
	spi_delay_task(1);
	RFRxFlushFIFO();
	spi_delay_task(1);
	//0 rx 1 tx 
	if(nRFMode ==MD_TX)
	{
		
		RFWriteCmd(NRF_RF_CONFIG,RF_TRANSMIT_MODE);
		spi_delay_task(1);
		RFWriteCmd(NRF_EN_AA,0x01);  		// Enable ACK Pipe-0
		RFWriteCmd(NRF_EN_RXADDR,0x01);   	// Enable Receive Pipe-0
		RFWriteCmd(NRF_SETUP_AW,0x03);   	// Address:5-bytes
		RFWriteCmd(NRF_SETUP_RETR,0x25);   	//Auto-Retransmit x 5@@750uS
		RFWriteCmd(NRF_RF_CH,1);			//CH1
		RFWriteCmd(NRF_RF_SETUP,0x27);   	// 250Kbps
		RFWriteCmd(NRF_DYNPD,0x01);   		//Enable dynamic payload Pipe-0
		RFWriteCmd(NRF_FEATURE,0x06);   	//EN_DPL:ON, EN_ACK_PAY:ON
	}
	else
	{
		
		RFWriteCmd(NRF_RF_CONFIG,RF_RECEIVE_MODE);
		spi_delay_task(1);
		RFWriteCmd(NRF_EN_AA,0x01);  		// Enable ACK Pipe-0
		RFWriteCmd(NRF_EN_RXADDR,0x01);   	// Enable Receive Pipe-0
		RFWriteCmd(NRF_SETUP_AW,0x03);   	// Address:5-bytes
		RFWriteCmd(NRF_SETUP_RETR,0x25);   	//Auto-Retransmit x 5@@750uS		
		RFWriteCmd(NRF_RF_CH,nRFFreqHopTab[FREQ_HOP_GRP&0x03][0]); 
		RFWriteCmd(NRF_RF_SETUP,0x27);   	// 250Kbps
		RFWriteCmd(NRF_DYNPD,0x01);   		//Enable dynamic payload Pipe-0  When EN_AA EN_DPL 
		RFWriteCmd(NRF_FEATURE,0x06);   	//EN_DPL:ON, EN_ACK_PAY:ON

		
	}

		
		RFSetTXRXAddr();
		
		if(nRFMode !=MD_TX)
		{
			RFSetup(0x27);
		}
		RFCEHIGH();
	#endif
		nRFInitDone=1;
}

void PariRemoterInit()
{
	if(nRFSpiMode==GPIOSPI)	
	{
		GpioSPIInit(1);
	}	
	else
	{
		HWSPIInit();
		gRFDriverInit();
	}

}

// RF_Chip_Rx_Burst_Data 
static int RFRxBurstData(void)
{
	
	UINT8 len;
	UINT8 i,ret;

	ret=0;
	len=RFReadWriteCmd( NRF_R_RX_PL_WID,1);

	printf("len=%d\n",len);	
	if(len>32) len=32;
	if(len)
	{
		RFReadWriteCmd( NRF_R_RX_PAYLOAD,len);
		if(nRFSpiMode==GPIOSPI) 
		{
			for(i=0;i<len;i++)
			{			
				ReadPLDataBack[i]=  ReadPLData[i+1];				
			}
		}
		else
		{
				for(i=0;i<len;i++)
				{			
					ReadPLDataBack[i]=  ReadPLData[i];				
				}
		}			
		ret=len;
	}
	return(ret);
}



static void RFTxBurstDataReSend(void)
{
	UINT8 Buf[5];
	int i=0;			
	Buf[i++]= 0x12;
	Buf[i++]= 0x34;
	Buf[i++]= 0x56;
	Buf[i++]= 0x78;
	Buf[i++]= 0x9A;

	RFWriteDat(NRF_W_TX_PAYLOAD,Buf,i );  //error  NRF_W_REGISTER
}

static void RFTxBurstDataCustom(UINT8 *p,UINT8 len)
{
	RFWriteDat(NRF_W_TX_PAYLOAD,p,len );
}

static void RFReSendCode(void)
{
	RFClearIrq();
	spi_delay_task(1);
	RFTxFlushFIFO();
	spi_delay_task(1);
	RFTxBurstDataReSend();
	spi_delay_task(2);		
	RFCEHIGH();  //10us high 
	spi_delay_task(60);	
	RFCELOW();		
	printf("nRF2401 Send code..\n");

}


// Check paring  Cmd Word  by wrist watch send 
static int RFParingComp(UINT8 len)
{
	
	if(!nRFParingMode) 
		return(0);
	
	if(len!=5) 
	{
		printf("paring length [%d]!=5bytes\n",len);
		return(0);
	}
	///1f AA 55 AA 55 B
	if( (ReadPLDataBack[2]==0x55) && (ReadPLDataBack[1]==0xAA) && (ReadPLDataBack[0]==0x1f) )
	{
		printf("Pair Success!!!\n");
		return(1);
	}
	printf("Pair Fail !!!\n");
	return(0);
}


//  prepare camera ID( CUID) for pairing Mode ACK-payload

void RFParingID(void)
{
	//if(nRFParingMode)
	{     
	
		UINT8 Buf[8];		
		UINT8 i;
		i=0;		
		if((nPairRandomCUID>=1) && (nPairRandomCUID<=99999 ))
		{		
			Buf[i++]= (UINT8)(nPairRandomCUID&0x00ffL);
			Buf[i++]= (UINT8)((nPairRandomCUID>>8)&0x00ffL);
			Buf[i++]= (UINT8)(((nPairRandomCUID>>16)&0x00ffL)  );
			Buf[i++]= DateCUID.Week;
			Buf[i++]= DateCUID.Year;			
		}
		else
		{

			//NO CUID, default ID value
			Buf[i++]= CUSTOMER_ADDR4;  //0X0A  9 8 7 6 
			Buf[i++]= CUSTOMER_ADDR3;   
			Buf[i++]= CUSTOMER_ADDR2;
			Buf[i++]= CUSTOMER_ADDR1;
			Buf[i++]= CUSTOMER_ADDR0;		
		}

              Buf[i++] = 0xAA; //pair package head 
		RFWriteDat(NRF_W_ACK_PAYLOAD|RF_PIPE_0,Buf,i );	//0a 09 08 07 06				
		//printf("nRF2401 ACK CUID =0x%x 0x%x 0x%x 0x%x 0x%x\n",Buf[0],Buf[1],Buf[2],Buf[3],Buf[4]);

	}

}
void RF24ParingFail(void)
{
	if(nRFParingMode)
	{     
		
		UINT8 Buf[5];	
		int i=0;
     		//printf("Worng CUID code!\n");
     		
		Buf[i++] = PARN_FAIL_CODE0;
		Buf[i++] = PARN_FAIL_CODE1;
		Buf[i++] = PARN_FAIL_CODE2;
		Buf[i++] = PARN_FAIL_CODE3;
		Buf[i++] = PARN_FAIL_CODE4;		
		RFWriteDat(NRF_W_ACK_PAYLOAD|RF_PIPE_0,Buf,i );

		printf("nRF2401 ACK Rply-payLoad =0x%x 0x%x 0x%x 0x%x 0x%x\n",Buf[0],Buf[1],Buf[2],Buf[3],Buf[4]);

	}

}


void  RFSetCameraFileNum(UINT16 nFileNum)
{
	printf(">>>RF2401, Set  fileNum=%d\n",nFileNum);
	CamFileNum = nFileNum;
}
void RFSetCameraStatus(UINT8 nSts)
{
	//printf(">>>RF2401, Set  CamStatus=%d\n",nSts);
	CamStatus= nSts;
}

void RFSetCameraError(UINT8 nError)
{
	//printf(">>>RF2401, Set  CamError=%d\n",nError);
	CamErrorCode= nError;
}

 int CameraStatusAckRply(void)
{
	
	static UINT8 Buf[8];
	UINT16 nChkSum;
	static UINT8 tmp=0;
	UINT8 i=0,j=0;
	
    	if(gRF24Init==0) 
		return -1;
		
    	RFTxFlushFIFO();
	Buf[i++]= (UINT16)(CamFileNum&0xff);  //total number of  DCIM file
	Buf[i++]= (UINT16)((CamFileNum>>8)&0xff);  
	Buf[i++]= CamStatus; //Current Camera  Status
	Buf[i++]= CamErrorCode; //Camera Error code
	nChkSum=0;	
	for(j=0;j<i;j++)
	{
		nChkSum+=Buf[j];
	}
	Buf[i++] = (UINT8)nChkSum;
    
	RFWriteDat(NRF_W_ACK_PAYLOAD|RF_PIPE_0,Buf,i );
	
	printf("5M2 Status Upload >>>  0x%x 0x%x 0x%x 0x%x chks=0x%x , len=%d\n",Buf[0],Buf[1],Buf[2],Buf[3],nChkSum,i);
    
     return(0);
}


static int RFMonitorRxIrq(void)
{
	UINT32 nIrqTriger=1;
	int ret,len;
		
	nIrqTriger=GetRF_IRQLevel();
	ret=0;
	//printf("uRF2401_GpioIRQ=%d\n",nIrqTriger);
	if(nPairAddrEnable==1)
	{
		//RFCELOW();
		RFSetTXRXAddr();
		//RFCEHIGH();
		nPairAddrEnable=0;
	}
	
	if(nIrqTriger==0)
	{
		len=RFRxBurstData();
		ret=len;
		RFRxFlushFIFO();
		if(nRFParingMode)
		{
			if(RFParingComp(len))
			{	
	                    	 spi_delay_task(4);
	                      nRFParingMode = 0;								
	                      RFSetTXRXAddr();						   
				 RFParingID();							
				 printf("--nRFParingMode=%d\n",nRFParingMode);												
			}
			else
			{
			      	RF24ParingFail(); 
			}
		}
			
	     	RFClearIrq();		
            	if(!nRFParingMode)
		{
                   	spi_delay_task(4);
			CameraStatusAckRply();
            	}				
	} 
	else if(nRFParingMode)
	{       
			//paring mode, pre put paring ID to nRF2401 buffer
			RFTxFlushFIFO();
	       	RFParingID();
	        	//printf("set Paring ID\n");
	}       
   return(ret);
}


void RF24IRQCallBack(void)
{
	
	if(nRFInitDone==0) 
		return;   
	RFMonitorRxIrq();
}



//0x1d cmd rollkey ver  
void RFRxMsgFilter(UINT8 *uCmdStr,UINT8 nLen)
{
    
    
    UINT8 nkeyID,nKeyCode,nVer;
    static int KeyRollMark=(-1);   
    UINT32  curAppMode = 0;
    UINT8* puiPara = NULL; 
	
    //puiPara = appUiParaGet();	
    //printf("RC input len =%d\n",nLen);
    //printf("Key code =0x%x 0x%x 0x%x Ver=%d\n", uCmdStr[0],uCmdStr[1],uCmdStr[2],uCmdStr[3]);
    
    nVer = uCmdStr[3];//newest 0x12  old ver is 0
    nkeyID =(uCmdStr[0]&0x1f); //0x1d   
    nKeyCode =uCmdStr[1];  //keycode  


    //sp5kModeGet(&curAppMode);
    //appStateChange(APP_STATE_SPORTDV_VIDEO_PREVIEW, STATE_INIT);	
    CamStatus = CAMST_IDLE;
    //curAppMode = appActiveStateGet();	
#if 0
    switch(appActiveStateGet())
    {									
		case APP_STATE_SPORTDV_VIDEO_REC:
		case APP_STATE_SPORTDV_VIDEO_REC_SLOW:
		case APP_STATE_CARDV_VIDEO_REC:
		case APP_STATE_CARDV_VIDEO_REC_LAPSE	:
			CamStatus = CAMST_REC;
			printf("---video record\n");
			break;		
		default:
			 break
	
    }		
#endif

   CamErrorCode=CAMERR_OK;
      
   //return;	
	  
	    if(nkeyID==0x1d)
	    {
	        if(KeyRollMark !=uCmdStr[2]) //roll key
		 {
		            KeyRollMark =(unsigned int)uCmdStr[2];
		            if(nKeyCode==START_RECORD)
				{
		                         			          										
					sp5kHostMsgSend(APP_UI_MSG_RF_REC,0); //normal , rec slow	
					printf("---rec1\n");
		            }
			     else if(nKeyCode==STOP_RECORD)
			     {
					sp5kHostMsgSend(APP_UI_MSG_RF_REC,0);
					printf("---rec2\n");
			     }	 
			     else if(nKeyCode==SNAP)
			     {		                		              
			             sp5kHostMsgSend(APP_UI_MSG_RF_SNAP,0);
					printf("--snap3\n");	 
		            }	  
			    else if(nKeyCode==REQUEST_SATUS)
			     {
		            
		            }           
	        }
		else
		{
	        
	        }
	       
	    }
   


}



void  RFRxTimerCallBack(ULONG nEID)
{
	UINT8 len=0,i=0;
	static UINT8 nRFHopCnt=0;
	static UINT8 nRxLostCnt=0;


	while(1)
	{

		sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 100);
		
		len=RFMonitorRxIrq();		
		if(len)
		{
			
			if(!nRFParingMode)
			{                								
				RFRxMsgFilter(&ReadPLDataBack[0],len);
			}
			else
			{
				//Parining Action		
			}		               
			nRxLostCnt=0;
		}

		if(++nRxLostCnt>=15){
			nRxLostCnt=0;
			nRFHopCnt++;
			RFChgTXRXCh(nRFHopCnt);
		}

	}
	//RFReSendCode();
}


#if 0
void appGsensorInit(UINT8 mode)
{
	printf("appGsensorInit Begain:%d\n", mode);
	if(mode == GSENSOR_NORMAL_INIT)
	{
		gSensorDriverInit(mode);
		appGsensorSensortivitySet();
		//sp5kGpioIsrReg(GSENSOR_INTRRUP_PIN, SP5K_TRIG_LVL_RISE, appGSensorIsrSvrFunc);
		if(pThreadGSensor == NULL)
		{
			pThreadGSensor = sp5kOsThreadCreate("GSensor", appGSensorThread, 0, 16, 16, 3, TX_AUTO_START);
		}
	}
	else		//GSENSOR_COLLISIONDET_INIT
	{
		if(pThreadGSensor != NULL)
		{
			sp5kOsThreadTerminate(pThreadGSensor);
			sp5kOsThreadDelete(pThreadGSensor);
			pThreadGSensor = NULL;
		}
		gSensorDriverInit(mode);
		appGsensorSensortivitySet();
		//sp5kGpioIsrUnreg(GSENSOR_INTRRUP_PIN, SP5K_TRIG_LVL_RISE);
	}	
	printf("appGsensorInit End:%d\n", mode);
}
#endif





#define MAX_RT  (1<<4)
#define TX_DS  (1<<5)
#define RX_DR  (1<<6)

int CheckRFStatus(UINT8 rfmode)
{
	RFReadWriteCmd( NRF_RF_STATUS,1);//NOP
	UINT8 sr=(UINT8)ReadPLData[0];
	if(rfmode==MD_TX)
	{
		
		if(sr&MAX_RT)	
		RFTxFlushFIFO();	
	 	
		//RFClearIrq();    
	       // 清除TX_DS或MAX_RT中断标志  
	   
	    	if(sr&TX_DS) 
	    	{
			RFRxBurstData();			
			RFRxFlushFIFO();
			RFWriteCmd(NRF_RF_STATUS,sr);
			printf("sr=0x%x\n",sr);
			printf("r=%d send ok\n",(UINT8)ReadPLDataBack[0]);						
			return(0x00);  
	    	}		
	    	else if(sr&MAX_RT) 
	    	{
			printf("max rt 0x%x\n",sr);	
			RFWriteCmd(NRF_RF_STATUS,sr);
	    	}
		else
		{
			if(sr&RX_DR) 
			printf("ack rec ok 0x%x\n",sr);
			RFWriteCmd(NRF_RF_STATUS,sr);

		}
	        	
	}
	else
	{
		if(sr&RX_DR) 
			printf("rec ok\n");	
		RFWriteCmd(NRF_RF_STATUS,0x70);
		RFRxFlushFIFO();
			
	}
	return(0xff);  
	
}

void PTX_Mode(ULONG iIrq)
{
	UINT8 data_buffer;
	UINT8 Buf[32];
	UINT8 i;
	UINT8 IRQ;
	printf("PTX_Mode\n");

	// PTX Mode Setup
	
	RFCELOW();
	RFWriteCmd(RF_CH_MAP, PingPongCH);	// RF Channel, Set channel = (2400 + channel) (MHz)
	RFWriteCmd(EN_AA_MAP, 0x01);			// Enable Auto Ack, enable Auto Ack pipe0
	//RFWriteCmd(EN_AA_MAP, 0x00);
	RFWriteCmd(EN_RXADDR_MAP, 0x01); 		// Enable RX Address, enable pipe0 address
	RFWriteCmd(SETUP_AW_MAP, 0x03);		// Setup of Address Width, 5 bytes address width
	RFWriteCmd(RX_PW_P0_MAP, 0x01);		// RX Payload Width, Set number of bytes in RX payload = 1 byte
	RFWriteCmd(RF_SETUP_MAP, 0x06); 		// Data Rate = 1Mbps, RF_PWR = 0dBm
	RFWriteCmd(NRF_FEATURE,0x02);			//luo enable ack payload
	//RFWriteCmd(NRF_FEATURE,0x00);	
	//Set_TX_Addr('I', 'f', 'r', 'i', 't');  // Transmit address, LSByte write first
	//Set_Pipe0_RX_Addr('I', 'f', 'r', 'i', 't'); // Receive address data pipe 0, LSByte write first.
	i=0;
	Buf[i++]='D';
	Buf[i++]='X';
	Buf[i++]='G';
	Buf[i++]='R';
	Buf[i++]='F';		
	RFSetRxAddr(Buf,1);
	//Buf[3]='X';
	//Buf[4]='X';	
	RFSetTxAddr(Buf,1);

	RFWriteCmd(SETUP_RETR_MAP, 0x25); // Disable re-transmit
	RFWriteCmd(CONFIG_MAP, 0x5E);		// TX_DS reflected IRQ, Set to PTX
	spi_delay_task(2000); 				// Max 1.5ms start-up from power down mode

	RFWriteCmd(STATUS_MAP, 0x70);		// Clear all interupt flag	01110000
	RFTxFlushFIFO();// Flush Tx FIFO
	RFRxFlushFIFO();

	//Start PTX Mode
	
	while(1) {	

		sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 100);
		CheckRFStatus(MD_TX);
		RFTxFlushFIFO(); //Flush_tx_command();		
		Buf[0]='K';
		RFWriteDat(0xA0, Buf, 1);		
		RFWriteCmd(STATUS_MAP, 0x70);	// Clear all interupt flag
		RFCEHIGH();			
		spi_delay_task(20);///10us
		RFCELOW();	
		sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 1);
		//if(GetRF_IRQLevel()==0)		
		//CheckRFStatus(NRF_MD_TX);
		
	}
	//Mode_Select();	
	
}//end of PTX_Mode()


void PRX_Mode(ULONG iIrq)
{
	UINT8 data_buffer=0;
	UINT8 Buf[32];
	UINT8 i;
	UINT8 IRQ;
	UINT8  nrArray[32];
	
	//IRQ = (iIrq)?(0):(1);
	printf("PRX_Mode\n");


	// PRX Mode Setup	
	RFCELOW();
	RFWriteCmd(RF_CH_MAP, PingPongCH);	// RF Channel, Set channel = (2400 + channel) (MHz)
	RFWriteCmd(EN_AA_MAP, 0x01);			// Enable Auto Ack, enable Auto Ack pipe0
	RFWriteCmd(EN_RXADDR_MAP, 0x01); 	// Enable RX Address, enable pipe0 address
	RFWriteCmd(SETUP_AW_MAP, 0x03);	// Setup of Address Width, 5 bytes address width
	RFWriteCmd(RX_PW_P0_MAP, 0x01);	// RX Payload Width, Set number of bytes in RX payload = 1 byte
	RFWriteCmd(RF_SETUP_MAP, 0x06); 	// Data Rate = 1Mbps, RF_PWR = 0dBm
	RFWriteCmd(NRF_FEATURE,0x02);
	i=0;
	Buf[i++]='D';
	Buf[i++]='X';
	Buf[i++]='G';
	Buf[i++]='R';
	Buf[i++]='F';
	RFSetTxAddr(Buf,1);
	RFSetRxAddr(Buf,1);

	RFWriteCmd(CONFIG_MAP, 0x3F);	// Reflect RX_DR reflected IRQ, Set to PRX
	//spi_delay_task(2000); // Max 1.5ms start-up from power down mode
	sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 3);

	RFWriteCmd(STATUS_MAP, 0x70);	// Clear all interupt flag	
	RFRxFlushFIFO(); //Flush_rx_command(); // Flush Rx FIFO
	
	//gpio_clr(uRF2401_GpioCE); //CE = 1;
	RFCEHIGH();
	spi_delay_task(1);

	// Start PRX Mode
	
	while(1) {

			sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 100);
			//while(GetRF_IRQLevel());
			if(GetRF_IRQLevel()==0)
			{
				//if(GetRF_IRQLevel()==0)			
				RFRxBurstData();	
				//printf("K=[%c]\n",(UINT8)ReadPLDataBack[0]);
				nrArray[0]='R' ;
				RFWriteDat(NRF_W_ACK_PAYLOAD|RF_PIPE_0,nrArray,1 );
				CheckRFStatus(MD_RX);
			}
		
	}		
}


void 
inRF2401_monCmd(UINT32 argc,	UINT8 *arg[], UINT32 v[])
{
	UINT32 addr,dat,len,cmd;
	UINT8 Buf[32];
	UINT8 i;

	if (argc >= 2 && strcmp(arg[1], "spi") == 0) {
	}
	else if (argc >= 2 && strcmp(arg[1], "spi_cfg") == 0) {

		//dat = atoi(v[2]);  
		dat=v[2];
		if(dat)
		{			
			nRFSpiMode=HWSPI;			
		}
		else
		{
			nRFSpiMode=GPIOSPI;			
		}
		printf("spi gpio=%d\n",nRFSpiMode);
	}	
	else if (argc >= 2 && strcmp(arg[1], "init") == 0) 
	{
		dat = v[2];  //mode  0123	
		nRFMode=dat;
		if(nRFMode) 
		{
			printf("Init TX mode...=%d\n",nRFMode);
		}
		else
		{
			printf("Init RX mode...=%d\n",nRFMode);
		}
		//vdxgapp_nRF2401_Init();        
	}	
	
	return ;
}

void PRX_TEST(ULONG nParam)
{

	while(1)
	{
		sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 100);
	}
}

#if 0
//UINT32  fnPairCuidReadFile();RfRemoterParingFinish
static cmd_t rfspicmds[] = {
	{ "cesethigh", RFCEHIGH,     "custom 1", NULL, },
	{ "cesetlow",  RFCELOW,     "custom 2", NULL, },		
	{ "ceclkhigh",  vGpioRF_sckSetHigh,     "custom 4", NULL, },
	{ "ceclklow",  vGpioRF_sckSetLow,     "custom 5", NULL, },
	{ "cemosihigh",  vGpioRF_MosiSetHigh,     "custom 6", NULL, },	
	{ "cemosilow",  vGpioRF_MosiSetLow,     "custom 7", NULL, },	
	{ "irqlevel",  GetRF_IRQLevel,     "custom 9", NULL, },
	{ "cecsnhigh",  vGpioRF_CsnSetHigh,     "custom 10", NULL, },
	{ "cecsnlow",  vGpioRF_CsnSetLow,     "custom 10", NULL, },
	{ "cerfinit",  vGpioRF_Init,     "custom 10", NULL, },	
	/*{ "readcuid",  fnPairCuidReadFile,     "custom 10", NULL, },*/
	{ "hwspi",  TestHWSpi,     "custom 10", NULL, },
	{ "pair",  RfRemoterParingStart,     "custom 10", NULL, },
	{ "rfinit",  RfRemoterInit,     "custom 10", NULL, },
	{ "rfrs",  RfRemoterRelease,     "custom 10", NULL, },
	{ "past",  RfRemoterParingFinish,     "custom 10", NULL, },
	{ NULL,  NULL,            NULL, NULL, }, /* null terminator */
};
#endif

#if 0
int appRFInit(void)
{
	UINT8* puiPara = NULL;

	printf("---appRFInit 888\n");
	#if 0
	//puiPara = appUiParaGet();
	
	//puiPara->nCUID[0]=12;
	//puiPara->nCUID[1]=34;
	//puiPara->nCUID[2]=10;
	//puiPara->nCUID[3]=98;
	//puiPara->nCUID[4]=76;
	//puiPara->nPairMode=0;
	
	DateCUID.Year=puiPara->nCUID[0];	
 	DateCUID.Week=puiPara->nCUID[1];	
	//nPairRandomCUID=0x00<<16|0x09<<8|0x0a;
	nPairRandomCUID=0;
	nPairRandomCUID = puiPara->nCUID[2]<<16;
	nPairRandomCUID += puiPara->nCUID[3]<<8;
	nPairRandomCUID += puiPara->nCUID[4];
	#endif
	//puiPara = appUiCUIDParacGet();
	
	//puiPara->nCUID[0]=12;
	//puiPara->nCUID[1]=34;
	//puiPara->nCUID[2]=10;
	//puiPara->nCUID[3]=98;
	//puiPara->nCUID[4]=76;
	//puiPara->nPairMode=0;
	
	DateCUID.Year=puiPara[0];	
 	DateCUID.Week=puiPara[1];	
	//nPairRandomCUID=0x00<<16|0x09<<8|0x0a;
	nPairRandomCUID=0;
	nPairRandomCUID = puiPara[2]<<16;
	nPairRandomCUID += puiPara[3]<<8;
	nPairRandomCUID += puiPara[4];
	
	printf("--UI CUID =%d %d %d\n",puiPara[2],puiPara[3],puiPara[4]);
	printf("--UI year=%d week=%d %d\n",DateCUID.Year,DateCUID.Week,nPairRandomCUID);		


	cmdBatchRegister(rfspicmds);
	
	#if 0
	nRFSpiMode = GPIOSPI;
	nRFMode=MD_RX;
	#else
	nRFSpiMode = HWSPI;
	nRFMode=MD_RX;
	#endif	
	
	nRFParingMode =0;	
	nRF2401_MemoryInit();
	  	
	RF2401Init();
	spi_delay_task(100);	
	//5k8 no transfer video may use timer polling 
	//TestHWSpi();
	
    	//appTimerIsrReg(RFRxTimerCallBack,RF2401_RF_RX_SCAN_RATE); 
	#if 1
    	if(nRFMode==MD_TX)
    	{
		if(pThreadRFSend == NULL)
			pThreadRFSend = sp5kOsThreadCreate("RF Send", PTX_Mode, 0, 16, 16, 3, TX_AUTO_START);
    	}
	else if(nRFMode==MD_RX)
	{
		if(pThreadRFReceive == NULL)
		{
			printf("rf thread for rec\n");
			pThreadRFReceive= sp5kOsThreadCreate("RF Rec", RFRxTimerCallBack, 0, 16, 16, 3, TX_AUTO_START);
		}
	}
       #endif 	   	   	 
   	gRF24Init=1;
	return(1);
	
}
#endif


void RF24L01DriverLoad(void)
{	
	//UINT8  nBuf[5]={0x01,0x02,0x00,0x04,0x05};	
	//cmdBatchRegister(rfspicmds);
	//RfRemoterInit(NULL);
	//RfRemoterInit(nBuf);
}


/*
return 0:ok
1:len error  or nCUID is too big
nCUID[0]=year nCUID[1]=week  1=<(nCUID[2]<<16|nCUID[3]<<8 |nCUID[4])<=99999
*/
UINT8 RFRemoterSetCUID(UINT8 *nCUID,UINT8 nLen)
{

	UINT8 *puiPara=NULL;	
	puiPara = nCUID;
	if(nLen!=5)
	{
		return 1;
	}
	else
	{
		DateCUID.Year=puiPara[0];	
	 	DateCUID.Week=puiPara[1];	
		//nPairRandomCUID=0x00<<16|0x09<<8|0x0a;
		nPairRandomCUID = 0;
		nPairRandomCUID = puiPara[2]<<16;
		nPairRandomCUID += puiPara[3]<<8;
		nPairRandomCUID += puiPara[4];
		if(nPairRandomCUID>=1&&nPairRandomCUID<=99999)
		{ 
			
		}
		else
		{
			nPairRandomCUID = 0x015B38;
			return 1;
		}
	}
	printf("--UI CUID =%d %d %d\n",puiPara[2],puiPara[3],puiPara[4]);
	printf("--UI year=%d week=%d %d\n",DateCUID.Year,DateCUID.Week,nPairRandomCUID);
	return 0;


}

void   RfRemoterInit(UINT8 CUID[5])
{

	//static UINT8 nCmdReg=0;
	UINT8 *puiPara=NULL;
	//UINT8  nBuf[5]={0x01,0x02,0x00,0x04,0x05};
	
	if(CUID)
		RFRemoterSetCUID(CUID,5);
	//else  default CUID
		
	nRfSwich = 1;
	
	printf("--nRfSwich=%d\n",nRfSwich);	
	printf("--oUI year=%d week=%d 0x%x\n",DateCUID.Year,DateCUID.Week,nPairRandomCUID);
	
	#if 0
	nRFSpiMode = GPIOSPI;
	nRFMode=MD_RX;
	#else
	nRFSpiMode = HWSPI;
	nRFMode=MD_RX;
	#endif	
	
	nRFParingMode =0;
	nPairAddrEnable = 0;
	nRF2401_MemoryInit();
	  	
	RF2401Init();
	spi_delay_task(100);	
	
	//cmdBatchRegister(rfspicmds);
	
	if(pThreadRFReceive == NULL)
	{
			
		pThreadRFReceive= sp5kOsThreadCreate("RF Rec", RFRxTimerCallBack, 0, 16, 16, 3, TX_AUTO_START);
		printf("rec thd create\n");
	}	
	//printf("--nRfSwich end\n");

}



void RfRemoterRelease(void)
{

 	if(pThreadRFReceive != NULL)
	{
			sp5kOsThreadTerminate(pThreadRFReceive);
			sp5kOsThreadDelete(pThreadRFReceive);
			pThreadRFReceive = NULL;
			printf("rec thd destroy\n");
	}

}

#if 0
void RF()
{
	static TX_MUTEX sRFPairMenuMutex=NULL;
		
	if(sRFPairMenuMutex==0)
		sp5kOsMutexCreate(&sRFPairMenuMutex, "RFPairMutex", 0);
	if(sRFPairMenuMutex!=NULL)	
		sp5kOsMutexDelete(&sRFPairMenuMutex);
	
	sp5kOsMutexGet(&sRFPairMenuMutex, 0);
	sp5kOsMutexPut(&sRFPairMenuMutex);

}
#endif

void RfRemoterPairingStart(void)
{
	nRFParingMode=1;
	nPairAddrEnable=1;
	if(nRFParingMode==1)
	{
		//PariRemoterInit();
		//RFCELOW();
		//RFSetTXRXAddr();
		//RFCEHIGH();
	}
	printf("---nRFParingMode=%d\n",nRFParingMode);
}	

BOOL RfRemoterParingFinish(UINT8 CUID[5])
{
	UINT8 i=0;
	printf("---nRFParingStatus=%d\n",nRFParingMode);
	if(nRFParingMode)
	{
		return 0;
	}	
	else
	{
			CUID[i++]= DateCUID.Year;
			CUID[i++]= DateCUID.Week;
			CUID[i++]= (UINT8)(((nPairRandomCUID>>16)&0x00ffL)  );
			CUID[i++]= (UINT8)((nPairRandomCUID>>8)&0x00ffL);
			CUID[i++]= (UINT8)(nPairRandomCUID&0x00ffL);
	}		
	return 1;
}	
//init RfRemoterInit();

UINT32 previewCallback(	UINT32 fid, UINT8 *pbuf,	UINT32 w,UINT32 h	)
{
	printf("fid=%d  %dx%d 1st pixel=%x", fid, w, h, *pbuf);
	return 0;
}
 
UINT32 previewCallbackTest(void)
{
	// call previewCallback every 3 frame & pass 160x120 YUV preview data into it
	printf("previewCallbackTest\n");
	sp5kPreviewCallbackSet(3, previewCallback, 160, 120);
	sp5kTimeDelay(SP5K_TIME_DELAY_1MS, 5000);
	// unregister preview YUV callback
	sp5kPreviewCallbackSet(0, NULL, 0, 0);
	return 0;
}

#if 0
//readcuid
UINT32  fnPairCuidReadFile()
{

	UINT32 fd;
	UINT32 size=0,len=0;
	UINT8 buffer[256];
	UINT32 nIndex=0;
	printf("--ReadCUID fnPairCuidReadFile\n");
	fd = sp5kFsFileOpen("D:\\CUID.TXT ", SP5K_FS_OPEN_RDONLY);
	
	if (fd) 
	{
		//sp5kFsFileClose(fd);
		printf("appCheckFocusMode Success!\n");
		//return TRUE;
	}
	else
	{
		printf("appCheckFocusMode Failed!\n");
		return 0;
	}
	size = sp5kFsFileSizeGet(fd);
	if(size<10||size>18)
	{
		printf("--error file length=%d\n",size);
	}	
	
	len = sp5kFsFileRead(fd, buffer, size);
	if(len<size)
	{
		printf("read no enough byte\n");
	}	

	if(memcmp( "CUID:", buffer, strlen("CUID:"))!=0)  //'0'
	{		
		printf("read no enough byte\n");
		return 0;
	}	
	nIndex=18-1;
	DateCUID.Year=(buffer[5]-'0')*10+(buffer[6]-'0');
	DateCUID.Week=(buffer[7]-'0')*10+(buffer[8]-'0');
	
	nPairRandomCUID=0;
	#if 0
	nPairRandomCUID+=(buffer[nIndex-1]-'0')*10+(buffer[nIndex]-'0');
	nPairRandomCUID+=((buffer[nIndex-3]-'0')*10+(buffer[nIndex-2]-'0'))*100;
	nPairRandomCUID+=((buffer[nIndex-5]-'0')*10+(buffer[nIndex-4]-'0'))*10000;
	#else
	nPairRandomCUID+=(buffer[nIndex-1]-'0')*10+(buffer[nIndex]-'0');
	nPairRandomCUID+=((buffer[nIndex-3]-'0')*10+(buffer[nIndex-2]-'0'))<<8;
	nPairRandomCUID+=((buffer[nIndex-5]-'0')*10+(buffer[nIndex-4]-'0'))<<16;
	#endif
	//109876
	printf("--Year=%d Week=%d CUID=%d 0x%x\n",DateCUID.Year,DateCUID.Week,nPairRandomCUID,nPairRandomCUID);
	sp5kFsFileClose(fd);
}
#endif


